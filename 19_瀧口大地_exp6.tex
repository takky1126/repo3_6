\documentclass[12pt]{ltjarticle}
\usepackage{enumitem}
\usepackage{caption}
\usepackage{graphicx}
\usepackage[hyphens]{url}
\usepackage{multirow}
\usepackage{float}
\usepackage{amsmath}
\usepackage{here}
\usepackage{array}
\usepackage{geometry}
\usepackage{microtype}
\usepackage{fontspec}
\usepackage{luatexja-fontspec} % 明示的に読み込む
\usepackage{luatexja}
\usepackage{titlesec}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{ascmac}

% ========== listings の設定 ==========
\lstset{
  % フレーム (枠線) の指定：上 (t) と 下 (b) の線だけ
  frame=tb, 
  % 枠線とコードの間の余白
  framesep=5pt, 
  % 等幅フォントで表示
  basicstyle=\ttfamily\small, 
  % 行番号を左側に表示
  numbers=left,
  % 行番号の書式を小さく（tiny）する
  numberstyle=\tiny, 
  % 行番号とコードの間のスペース
  numbersep=5pt, 
  % 行番号の増分 (1行ごと)
  stepnumber=1, 
}

% \usepackage{array}
% \usepackage{booktabs}
% \geometry{margin=20mm}
\titleformat{\section}[block]
  {\normalfont\LARGE\bfseries}
  {第\thesection 章}{1em}{}

\setmainfont{ipaexm.ttf} % 日本語フォント（IPAex明朝）を指定 ※ XeLaTeX or LuaLaTeXが必要
\geometry{left=25mm, right=25mm, top=30mm, bottom=30mm} % 余白設定
\renewcommand{\baselinestretch}{1.2} % 行間を1.2倍に設定

\counterwithin{figure}{section} % 図番号を「1.1」のようにセクションと連動
\counterwithin{table}{section}  % 表番号も同様にセクションと連動

\makeatletter
% section 再定義（改ページなし・見た目調整）
\renewcommand{\section}{%
  \@startsection{section}{1}{\z@}%
  {-2.5ex \@plus -1ex \@minus -.2ex}%
  {1.5ex \@plus.2ex}%
  {\normalfont\LARGE\bfseries\raggedright}%
}

% subsection 再定義（見た目だけ調整，番号はそのまま）
\renewcommand{\subsection}{%
  \@startsection{subsection}{2}{\z@}%
  {-1.5ex \@plus -0.5ex \@minus -.2ex}%
  {1ex \@plus .2ex}%
  {\normalfont\large\bfseries\raggedright}%
}

% section 番号だけ「第n章」に変更
\renewcommand{\thesection}{第\arabic{section}章}

% subsection 番号は従来の n.m 形式を保つ（これが重要）
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatother

\makeatletter
% 表番号を「2.1」「2.2」のようにセクション番号と連動
\renewcommand{\thetable}{\arabic{section}.\arabic{table}}
% キャプションの前に「表」を表示
\renewcommand{\tablename}{表}
% 参照の際にも「表」と表示
\renewcommand{\refname}{\tablename}
\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}
\renewcommand{\figurename}{図}
\makeatother

% キャプションの書式設定
\captionsetup[figure]{labelfont={bf}, labelsep=space, font=small}  % キャプションを小さくし，「図」を太字に設定

% タイトルと著者の設定
\title{\huge 第5章　サイバーセキュリティ基礎実験2}
\author{\large 3年情報工学科 19番 瀧口大地}
  
\date{} % 日付を空にする

\begin{document}

  \begin{titlepage}
    \vspace*{\fill}
    \begin{center}
      {\Large 情報工学実験 II 第5回レポート}\\
      \vspace{0.5\baselineskip}
      {\Huge サイバーセキュリティ基礎実験2}
    \end{center}

    \vspace{2cm}
    \begin{LARGE}
      \begin{center}
        3年 情報工学科 19番 瀧口大地
      \end{center}
    \end{LARGE}

    \begin{large}
    \vspace{1.5cm}
    \begin{flushleft}
      \normalsize
      提出期限: 2025年12月26日09:00\\
      提出日: 2025年12月22日23:00
    \end{flushleft}

    \vspace{1cm}
    \begin{flushleft}
      共同実験者:3班\\
       4番 井村周慈\\
       9番 カリラ\\
      14番 後藤輝一\\
      30番 三原瑚桜\\
      34番 山口紗音
    \end{flushleft}
    \end{large}

    \vspace*{\fill}
  \end{titlepage}

  \clearpage
  \setcounter{page}{1}
  \pagestyle{plain}

  \newpage
  \noindent
  \begin{huge}
    アブストラクト\\\\
  \end{huge}
  　本実験では，Python(パイソン)と呼ばれるスクリプト言語の文法や基本的な構造について
  学習し，Pythonを用いて様々なデータ整理や加工，テキストファイル処理及びツールの基本
  的な作成方法について習得すること，他のプログラミング言語と比較してPythonの特徴や
  利点についても学ぶことを目的とする．具体的にはPythonの基本文法を学ぶため，演算プ
  ログラム，九九表の出力プログラムを作成する．また，Pythonで用いられるモジュールを用
  いて日数計算プログラムを作成する．さらに，テキストファイルを読み込み，ソートするプ
  ログラム，重複データを削除するプログラムを作成する．それらの総括として，アクセスロ
  グから正規表現を用いてSQLコマンドインジェクションを検出するプログラム，各IPアド
  レスのアクセス回数を棒グラフとして出力するプログラムを作成する．また，発展的な課題
  としてmatplotlib を用いて，各IPアドレスのアクセス数を棒グラフとして出力するプログ
  ラムを作成する．具体的な方法として，重複データを削除するプログラムでは重複している
  かどうかの判定をsetを用いて行った．また，アクセスログから正規表現を用いてSQLコマ
  ンドインジェクションを検出するプログラムでは，SQLコマンドインジェクションで見られ
  る特徴的な文字列を正規表現で検出することで，検出を試みた．また，各IPアドレスのア
  クセス回数を棒グラフとして出力するプログラムでは，辞書を用いて各IPアドレスのアク
  セス回数をカウントしopenpyxlを用いてエクセルファイルに棒グラフを出力した．同様に
  matplotlib を用いて各 IP アドレスごとのアクセス数を棒グラフとして出力した．作成した
  これらのプログラムは実験時間内に作成し，正常に動作することが確認できた．

  \newpage
  \noindent
  % \setcounter{page}{1}
  \section{実験目的}
  　本実験では，Python(パイソン)と呼ばれるスクリプト言語の文法や基本的な構造について
  学習し，Pythonを用いて様々なデータ整理や加工，テキストファイル処理及びツールの基本
  的な作成方法について習得することを目的とする．また，他のプログラミング言語と比較し
  てPython の特徴や利点についても学ぶ．
  
  \newpage
  \section{実験結果}
  　指導書に示されたプログラミング課題をそれぞれアイデア，プログラム，結果に分けて
  述べていく．

  \subsection{スクリプトプログラミングの学習(6.10.1)}
  \subsubsection{アイデア}
  　本実験課題ではPythonを用いて簡単な演算を行う．演算子と役割は以下の表
  \ref{pythonでの四則演算子}に示すとおりである．
  
  \begin{table}[H]
    \centering
    \caption{pythonでの四則演算子}
    \label{pythonでの四則演算子}
    \begin{tabular}{|c|l|}
    \hline
    +  & 加算 \\ \hline
    -  & 減算 \\ \hline
    * & 乗算 \\ \hline
    /  & 除算 \\ \hline
    \% & 剰余 \\ \hline
    // & 除算（切り捨て） \\ \hline
  \end{tabular}
  \end{table}

  これらの演算子を用いて指導書に示されたサンプルプログラムを実行する．

  \subsubsection{プログラム}
  以下に指導書のサンプルプログラムを示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={サンプルプログラム}]
  print("10 + 3 =", 10+3)
  print("10 - 3 =", 10-3)
  print("10 * 3 =", 10*3)
  print("10 / 3 =", 10/3)
  print("10 % 3 =", 10%3)
  print("10 // 3 =", 10//3)
  \end{lstlisting}
  \end{figure}

  サンプルプログラムでは1行目から順に10と3の加算，減算，乗算，除算，剰余，切り捨て除算
  を行っている．

  \subsubsection{結果}
  サンプルプログラムを実行した結果を図\ref{サンプルプログラムの実行結果}に示す．

  \begin{figure}[H]
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    >python four_arithmetic.py
    10 + 3 = 13
    10 - 3 = 7
    10 * 3 = 30
    10 / 3 = 3.3333333333333335
    10 % 3 = 1
    10 // 3 = 3
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{サンプルプログラムの実行結果} 
    \label{サンプルプログラムの実行結果}
  \end{figure}

  図\ref{サンプルプログラムの実行結果}より，表\ref{pythonでの四則演算子}
  で示した通りに動作していることがわかる．よって指導書に示されたサンプルプログラムは
  正しく動作したと言える．

  \subsection{九九表の出力(6.10.2)}
  　本実験課題では図\ref{出力したい九九の表}のような九九表を出力するプログラムを作成する．

  \begin{figure}[H]
    \begin{center}
    \begin{screen}
    \begin{verbatim}
       |  1  2  3  4  5  6  7  8  9
    ---+---------------------------
      1|  1  2  3  4  5  6  7  8  9
      2|  2  4  6  8 10 12 14 16 18
      3|  3  6  9 12 15 18 21 24 27
      4|  4  8 12 16 20 24 28 32 36
      5|  5 10 15 20 25 30 35 40 45
      6|  6 12 18 24 30 36 42 48 54
      7|  7 14 21 28 35 42 49 56 63
      8|  8 16 24 32 40 48 56 64 72
      9|  9 18 27 36 45 54 63 72 81
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{出力したい九九の表} 
    \label{出力したい九九の表}
  \end{figure}

  \subsubsection{アイデア}
  図\ref{出力したい九九の表}の最初の2行はそれぞれ掛ける数と区切りの横線を出力
  しているだけである．3行目以降は掛ける数と同じような形で九九表が出力されているため，
  指導書の指定の通りにフォーマットを使うとコンパクトなコーディングができる．
  また，各数値は1桁のものでも2桁のものでも2桁相当の空間を取って出力するため，これも
  フォーマットを活用できる．

  \subsubsection{プログラム}
  アイデアに則って組んだ九九表を出力するプログラムを以下に示す．end=''は改行無しを示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={九九表を出力するプログラム}]
    # フォーマット
    f = " {0} |"
    n = " {0:2}"

    # 1行目
    print(f.format(" "),end='')
    for i in range(1,10):
        st = " " + (str)(i) # C++キャストも動く,というかnの意味よ
        print(n.format(st),end='')

    # 2行目
    print("\n"+"---+----------------------------")

    # 3行目以降
    for i in range(1,10):
        print(f.format(i),end='')
        for j in range(1,10):
            print(n.format(i*j),end='')
        print()
  \end{lstlisting}
  \end{figure}

  コメントにある通り，2～3行目がフォーマット，6～9行目が出力の1行目，
  12行目が出力の2行目，15～19行目が出力の3行目以降を処理している．

  \subsubsection{結果}
  図\ref{k001.pyの実行結果}に実行結果を示す．図\ref{k001.pyの実行結果}の九九表
  が図\ref{出力したい九九の表}と一致していることから，プログラムは正しく動作したと言える．
  
  \begin{figure}[H]
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    >python k001.py
       |  1  2  3  4  5  6  7  8  9
    ---+---------------------------
      1|  1  2  3  4  5  6  7  8  9
      2|  2  4  6  8 10 12 14 16 18
      3|  3  6  9 12 15 18 21 24 27
      4|  4  8 12 16 20 24 28 32 36
      5|  5 10 15 20 25 30 35 40 45
      6|  6 12 18 24 30 36 42 48 54
      7|  7 14 21 28 35 42 49 56 63
      8|  8 16 24 32 40 48 56 64 72
      9|  9 18 27 36 45 54 63 72 81
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k001.pyの実行結果}
    \label{k001.pyの実行結果}
  \end{figure}

  \subsection{閏年判定(6.10.3)}
  　本実験課題では入力された年が閏年かどうかを判定するプログラムを作成する．

  \subsubsection{アイデア[1]}
  Pythonにはcalendarモジュールというものがあり，これを用いることで
  1行のコードで与えられた数値型の年が閏年かどうかを判定できる．このモジュールを
  用いて本課題を解決する．

  \subsubsection{コード}
  前述のcalendarモジュールを用いて作成したコードを以下に示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={閏年判定プログラム}]
    import calendar

    year = input("何年（YYYY）：")
    year_i = int(year)

    if calendar.isleap(year_i):
        print(year_i , "年は閏年です。")
    else:
        print(year_i , "年は平年です。")
  \end{lstlisting}
  \end{figure}

  コードの1行目ではcalendarモジュールをインポートしており，3行目で年数の入力処理，
  4行目で入力の数値型変換，6行目以降でcalendarモジュールを用いた閏年判定と出力
  を行っている．

  \subsubsection{結果}
  以下の図\ref{k011.pyの実行結果}にプログラムで示したコードを実行した結果を示す．
  平年と閏年をそれぞれ入力し，正しい結果が出力されるか試した．

  \begin{figure}[H]
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    > python k011.py
    何年（YYYY）：2025
    2025 年は平年です。
    > python k011.py
    何年（YYYY）：2020
    2020 年は閏年です。
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k011.pyの実行結果}
    \label{k011.pyの実行結果}
  \end{figure}

  図\ref{k011.pyの実行結果}の出力結果から，閏年を閏年，平年を平年と出力できたことが
  わかる．このことから本実験のプログラムは正しく動作したと言える．

  \subsection{ファイル操作(6.10.4)}
  　本実験ではtemperature.datファイルを読み込み，昇順か降順か指定された順にソート
  するプログラムを作成する．

  \subsubsection{アイデア}
  本実験課題では入力に読み込むファイル(temperature.dat)と昇順か降順かを表す
  値（0,1）を入れる．次にそのdatファイルを読み込み，":"で区切られている日付と数値
  変換した温度とをセット（配列）として配列に格納する．その配列の中身を指定された
  通りにソートし，ファイルの更新を行う．また，指導書のコマンドプロンプト出力例に
  変更されたファイルの中身があったため，念のためprintによる出力も行う．本実験での
  ファイル操作は指導書の指定通りにwith文を用いて行うこととする．

  \subsubsection{プログラム}
  以下にアイデアに準じたプログラムを示す．

  他実験と同様に，本ソートプログラムの説明を各行で行う．1行目のdata配列は前述した
  セット（配列）を格納する配列である．3,4行目はファイルの名前とソート順の入力である．
  6～11行目は入力されたファイルをwith文で閲覧('r')し，for文を用いて行ごとに処理を
  行っている．処理の中身としては":"の前後で情報を区切り，それらをdate,tempとして
  data配列の中に格納している．ここで，tempはソートの際に数値として扱うためfloat型に
  変換している．15行目はコメントにある通り，ソート順を表す入力のRuleが1ならTrue,
  その他ならfalseとする変数を定義している．18行目はそれらを用いてソートを行っている．
  keyには扱うデータを参照させるのだが，データの位置を関数の出力しか指定できない．
  そのため簡易関数lambdaを使用してdataの1個目，つまり温度（0個目が日付）を参照して
  いる．21,22行目はコマンドプロンプト用にソートされたdata配列の中身を":"を挟み
  printで出力している．25～27行目はwith文の書き込み('w'で)datファイルを開き
  data配列の中身を上書きで書き込んでいる．

  \begin{figure}[H]
  \begin{lstlisting}[title={ソートプログラム}]
    data = []

    file_path = input("ファイル：")
    Rule = input("ルール（昇順：0,降順：1）")

    with open(file_path, 'r', encoding='utf-8') as f:
        for line in f:
            parts = line.split(':')
            date = parts[0]
            temp = float(parts[1])
            data.append((date, temp))

    #ソート処理 (昇順: 0, 降順: 1)
    # reverse=True で降順、False で昇順
    is_reverse = True if Rule == "1" else False

    #温度を基準にソート
    data.sort(key=lambda x: x[1], reverse=is_reverse)

    #出力処理
    for date, temp in data:
        print(f"{date}: {temp}")

    #ファイル書き換え（上書き）
    with open(file_path, 'w', encoding='utf-8') as f:
        for date, temp in data:
            f.write(f"{date}: {temp}\n")
  \end{lstlisting}
  \end{figure}

  \subsubsection{結果}
  まず指導書の出力例に則ってコマンドプロンプト上の出力結果を示す．
  最初にtemperature.datと1を入力し降順ソートを行った結果を図
  \ref{k023.pyの実行結果_cmd_1}に示す．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    > python k023.py
    ファイル：temperature.dat
    ルール（昇順：0,降順：1）1
    2015/Aug/08: 99.27
    2015/Aug/15: 39.65
    2015/Aug/02: 39.56
    2015/Aug/23: 39.25
    2015/Aug/20: 39.06
    2015/Aug/06: 37.93
    2015/Aug/26: 37.47
    2015/Aug/24: 37.12
    2015/Aug/19: 36.77
    2015/Aug/27: 36.48
    2015/Aug/05: 36.23
    2015/Aug/10: 35.71
    2015/Aug/29: 35.48
    2015/Aug/30: 35.39
    2015/Aug/17: 35.22
    2015/Aug/12: 34.75
    2015/Aug/09: 34.63
    2015/Aug/11: 34.52
    2015/Aug/25: 33.77
    2015/Aug/16: 33.62
    2015/Aug/07: 33.24
    2015/Aug/13: 32.59
    2015/Aug/03: 32.38
    2015/Aug/04: 32.36
    2015/Aug/18: 31.81
    2015/Aug/21: 31.65
    2015/Aug/01: 31.34
    2015/Aug/28: 31.13
    2015/Aug/14: 31.07
    2015/Aug/31: 30.12
    2015/Aug/22: 12.58
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k023.pyの実行結果(cmd)}
    \label{k023.pyの実行結果_cmd_1}
  \end{figure}

  図\ref{k023.pyの実行結果_cmd_1}を見るとコマンドプロンプトへの出力は
  正しく降順ソートされたと言える．次にこの状態のままもう一度k023を実行し
  temperature.datと0を入力し昇順ソートを行ったコマンドプロンプトの結果を
  図\ref{k023.pyの実行結果_cmd_0}に示す．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    > python k023.py
    ファイル：temperature.dat
    ルール（昇順：0,降順：1）0
    2015/Aug/22: 12.58
    2015/Aug/31: 30.12
    2015/Aug/14: 31.07
    2015/Aug/28: 31.13
    2015/Aug/01: 31.34
    2015/Aug/21: 31.65
    2015/Aug/18: 31.81
    2015/Aug/04: 32.36
    2015/Aug/03: 32.38
    2015/Aug/13: 32.59
    2015/Aug/07: 33.24
    2015/Aug/16: 33.62
    2015/Aug/25: 33.77
    2015/Aug/11: 34.52
    2015/Aug/09: 34.63
    2015/Aug/12: 34.75
    2015/Aug/17: 35.22
    2015/Aug/30: 35.39
    2015/Aug/29: 35.48
    2015/Aug/10: 35.71
    2015/Aug/05: 36.23
    2015/Aug/27: 36.48
    2015/Aug/19: 36.77
    2015/Aug/24: 37.12
    2015/Aug/26: 37.47
    2015/Aug/06: 37.93
    2015/Aug/20: 39.06
    2015/Aug/23: 39.25
    2015/Aug/02: 39.56
    2015/Aug/15: 39.65
    2015/Aug/08: 99.27
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k023.pyの実行結果(cmd)}
    \label{k023.pyの実行結果_cmd_0}
  \end{figure}

  図\ref{k023.pyの実行結果_cmd_1}からdata配列の更新とコマンドプロンプトへの
  出力が正しく行えたと言える．また，ファイルの更新が行えているかを確認する
  ために，図\ref{k023.pyの実行結果_cmd_1}時点のtemperature.datファイルと
  図\ref{k023.pyの実行結果_cmd_0}時点のtemperature.datファイルを記録していた．
  これらを図\ref{k023.pyの実行結果_file_1}と図\ref{k023.pyの実行結果_file_0}に
  示す．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    2015/Aug/08: 99.27
    2015/Aug/15: 39.65
    2015/Aug/02: 39.56
    2015/Aug/23: 39.25
    2015/Aug/20: 39.06
    2015/Aug/06: 37.93
    2015/Aug/26: 37.47
    2015/Aug/24: 37.12
    2015/Aug/19: 36.77
    2015/Aug/27: 36.48
    2015/Aug/05: 36.23
    2015/Aug/10: 35.71
    2015/Aug/29: 35.48
    2015/Aug/30: 35.39
    2015/Aug/17: 35.22
    2015/Aug/12: 34.75
    2015/Aug/09: 34.63
    2015/Aug/11: 34.52
    2015/Aug/25: 33.77
    2015/Aug/16: 33.62
    2015/Aug/07: 33.24
    2015/Aug/13: 32.59
    2015/Aug/03: 32.38
    2015/Aug/04: 32.36
    2015/Aug/18: 31.81
    2015/Aug/21: 31.65
    2015/Aug/01: 31.34
    2015/Aug/28: 31.13
    2015/Aug/14: 31.07
    2015/Aug/31: 30.12
    2015/Aug/22: 12.58
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k023.pyの実行結果(ファイル)}
    \label{k023.pyの実行結果_file_1}
  \end{figure}

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    2015/Aug/22: 12.58
    2015/Aug/31: 30.12
    2015/Aug/14: 31.07
    2015/Aug/28: 31.13
    2015/Aug/01: 31.34
    2015/Aug/21: 31.65
    2015/Aug/18: 31.81
    2015/Aug/04: 32.36
    2015/Aug/03: 32.38
    2015/Aug/13: 32.59
    2015/Aug/07: 33.24
    2015/Aug/16: 33.62
    2015/Aug/25: 33.77
    2015/Aug/11: 34.52
    2015/Aug/09: 34.63
    2015/Aug/12: 34.75
    2015/Aug/17: 35.22
    2015/Aug/30: 35.39
    2015/Aug/29: 35.48
    2015/Aug/10: 35.71
    2015/Aug/05: 36.23
    2015/Aug/27: 36.48
    2015/Aug/19: 36.77
    2015/Aug/24: 37.12
    2015/Aug/26: 37.47
    2015/Aug/06: 37.93
    2015/Aug/20: 39.06
    2015/Aug/23: 39.25
    2015/Aug/02: 39.56
    2015/Aug/15: 39.65
    2015/Aug/08: 99.27
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k023.pyの実行結果(ファイル)}
    \label{k023.pyの実行結果_file_0}
  \end{figure}

  図\ref{k023.pyの実行結果_file_1}，図\ref{k023.pyの実行結果_file_0}から
  ファイルの更新が適切に行えていることが分かった．

  以上のことから本プログラムは題意に沿って動作できたと言える．

  \subsection{コマンドライン引数(6.10.5)}
  　本実験では複数のファイルを指定し，それぞれのファイルの文字数，単語数，行数を
  カウントしそれぞれの結果を出力する．ただしプログラム引数でファイルを指定する必要があり，
  （python k032.py fruit.dat vegetable.dat wc.txt）といったような形にする．
  この例では最後の1つを除く全てのファイルであるfruit.datとvegetable.datの2つが
  カウントされるファイルであり，最後のwc.txtがカウントした結果が格納される
  ファイルである．

  \subsubsection{アイデア}
  入力を指定通りに行うためにsysモジュールのsys.argvを用いる（参考:指導書）．
  カウントされるファイルをこれまでと同様にwith文で読み込み，readlines関数で
  テキスト全体を読み取る．そこから行数，空白や改行のsplitによる単語数，
  単純な文字数を出力する．また，リストの配列を用いるため最終出力はリストを並べて出力
  できるjoinも用いる．最後にこれまでと同様にwith文の書き込みモードでカウントした
  データを一番後ろのファイルに格納する．

  \subsubsection{プログラム}
  以下にアイデアに準じたプログラムを示す．

  アイデアで述べた通り，1行目でsysモジュールをインポートし，3行目のsys.argv[1:-1]
  （ファイル指定の最初から最後の1個手前まで）を読み込むファイル，4行目sys.argv
  [-1]（ファイル指定の最後）を書き込むファイルとしている．6行目にリストを入れる配列
  resultsを定義している．8～20行目でアイデアにて述べた通りに行数，単語数，文字数を
  カウントしresultsにリストとして入れている．これを拡張for文で読み込むファイルの回数
  分行う．最後にjoinを用いてresultsコマンドプロンプトでの出力，ファイルへの書き込み
  を行い処理が終了する．

  \begin{figure}[H]
  \begin{lstlisting}[title={コマンドライン引数を用いたプログラム}]
    import sys

    output_file = sys.argv[-1]
    input_files = sys.argv[1:-1]

    results = []

    for filename in input_files:
        with open(filename, 'r', encoding='utf-8') as f:
            lines = f.readlines()
            
            l_count = len(lines)
            w_count = sum(len(line.split()) for line in lines)
            c_count = sum(len(line) for line in lines)
            
            # データの整形
            results.append(f"file: {filename}")
            results.append(f"lines: {l_count}")
            results.append(f"words: {w_count}")
            results.append(f"chars: {c_count}\n")

    # --- 追加：cmd上への表示とファイル書き込み ---
    output_text = "\n".join(results)
    print(output_text)

    # ファイルに保存
    with open(output_file, 'w', encoding='utf-8') as f_out:
        f_out.write(output_text)
  \end{lstlisting}
  \end{figure}

  \subsubsection{結果}
  プログラムを実行した結果を示す．今回はfruit.datとvegetable.datに資料にあった
  overlap.datから一部抜き出した内容を書き込みカウントされるファイルとして扱う．
  そのため以下に各datファイルの中身を示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={fruit.dat}]
    raspberry raspberry 
    grape 
    peach 
    cherry cherry cherry 
    grape cherry strawberry 
    peach 
    apple 
  \end{lstlisting}
  \end{figure}

  \begin{figure}[H]
  \begin{lstlisting}[title={vegetable.dat}]
    cherry mandarin orange apricot 
    apple banana apple 
    strawberry strawberry grape
  \end{lstlisting}
  \end{figure}

  これらを用いてプログラムk032を実行した際のコマンドプロンプト出力を図
  \ref{k032.pyの実行結果_cmd}に示す．  
  この時，vegetable.datの文字数が79となっているが，改行を除いた文字数が30+18+27
  =75文字であり改行は1文字で合計77文字となる．計算が合わないが良くファイルを確認
  すると最後の行以外の最後に半角空白があった．これで合計77となり計算が成り立つ．
  fruit.datでも同様に処理が行われているため，このような結果になったと分かる．思わぬ
  ハプニングだったが理論的に納得できた．以上のことから，内部の処理とコマンドプロンプト
  出力は正しく動作したと言える．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    > python k032.py .\fruit.dat .\vegetable.dat wc.txt
    file: .\fruit.dat
    lines: 7
    words: 12
    chars: 95

    file: .\vegetable.dat
    lines: 3
    words: 10
    chars: 79
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k032.pyの実行結果(cmd)}
    \label{k032.pyの実行結果_cmd}
  \end{figure}

  また，出力ファイルwc.txtの中身も図\ref{k032.pyの実行結果_file}に示し確認する．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    file: .\fruit.dat
    lines: 7
    words: 12
    chars: 95

    file: .\vegetable.dat
    lines: 3
    words: 10
    chars: 79
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k032.pyの実行結果(ファイル)}
    \label{k032.pyの実行結果_file}
  \end{figure}

  これでファイル出力も問題なく行えていることが分かった．

  以上のことから本実験課題のプログラムは想定・指定通りに動作したと言える．

  \subsection{アクセスログからの情報抽出(6.10.6.1)}
  　本実験課題では第5章実験で行った，Webサーバのアクセスログからアクセス数とアクセス元
  のIPアドレス数を調べる課題をPythonで行う．

  \subsubsection{アイデア[2]}
  IPアドレスの抽出やSQLインジェクションの検出は指導書の指定の通りreモジュールを使って
  解決する．指導書のURLが壊れていたためプログラム作成時に都度調べて書く．
  本課題で今までと違うのはreモジュールともう1つ，アクセス元のIPアドレス数という
  単純な数ではなく種類数を調べるところである．指導書にて軽く触れられているが，
  Pythonにはsetという重複を排除しながらデータを格納できる関数がある．
  これを用いることで効率的にアクセス元のIPアドレスを出力できる．
  また，リスト配列とは違ってset関数はハッシュ値を用いてデータを探すため，
  データの量が増えても検索速度が高速のままであるという長所もある．本実験課題の都合上
  その仕様が活きることはないが有用である．その他の機能は今までの実験課題で用いた
  機能を使いまわすだけである．withを用いたファイルの閲覧やjoinを用いた複数データの
  効率的な出力，sysによるコマンドライン引数の活用等をreモジュールやset関数と組み合わせ本実験課題の題意を満たす．

  \subsubsection{プログラム[3][4]}
  アイデアに準じたプログラムを以下に示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={アクセスログからの情報抽出を行うプログラム}]
    import sys
    import re

    # IPアドレス抽出用（行頭の数字列）
    ip_regex = re.compile(r'^(\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})')

    # ログ内の %27 ('), -- (コメント), %3D (=), OR などを検知
    sqli_regex = re.compile(r"(%27|'|--|%3D|or\s+)")

    input_file = sys.argv[-1]

    total_access = 0
    unique_ips = set()
    attacker_ips = set()

    with open(input_file, 'r', encoding='utf-8') as f:
        for line in f:
            total_access += 1
            
            # IPアドレスの抽出
            match = ip_regex.match(line)

            if match:
                ip = match.group(1)
                unique_ips.add(ip)

            # SQLインジェクションのパターンが含まれるかチェック
            if sqli_regex.search(line):
                attacker_ips.add(ip)

    # 結果の出力
    print("アクセス数：",total_access)
    print("アクセス元のIPアドレス数：",len(unique_ips))
    print("攻撃元のIPアドレス：",', '.join(attacker_ips))
  \end{lstlisting}
  \end{figure}

  1,2行目はモジュールのインポートを行っている．5,8行目ではreモジュールを用いて
  正規表現でIPアドレスとSQLインジェクションを検出している．具体的には，IPアドレスは
  行の先頭にあるため"$\text{\textasciicircum}$ "で先頭の要素に限定し，
  $\backslash d$(数値)の｛1,3｝(1～3文字のセット)と"."の連結で成り立つと定義した．
  SQLコマンドインジェクションの検出の方はコード内で説明されている通り特有の記号などを
  含むかどうかで定義している．10行目はコマンドライン引数の復習でaccess.logを入力する．
  12行目から14行目は合計アクセス数，アクセスしたIPアドレス，攻撃者のIPアドレスを扱う
  変数の定義である．2種のIPアドレスはset関数を用いて重複が起こらないようにデータを
  格納できるようにしている．16行目からのwith文も以前の課題と同様に行ごとのfor文で
  制御する．18行目では行ごとにアクセスが行われるためfor文が回るたびにアクセス数に1を
  加算している．21行目のようにip\_regex.match(line)とすることで行ごとのIPアドレスが
  先に定義したip\_regexに適する値があるかどうかをbool型で得られる．23～29行目では
  これを用いて2種IPアドレスに定義した正規表現に当てはまるものがあれば変数に追加
  するという処理を作っている．32,33行目はアクセス数とアクセス元のIPアドレスの出力を
  行っている．34行目ではSQLコマンドインジェクションを行ったIPアドレスを出力している．
  また，以下に今回使用したaccess.log(S0414)の中身のある1行を示す．これで最初の要素
  のみをIPアドレスとして使う理由やIPアドレスの正規表現のロジックを上のようにした理由
  等が裏付けられる．

  \begin{figure}[H]
  \begin{lstlisting}[caption={Apacheのログファイルの例},breaklines=true,breakatwhitespace=true]
    10.4.0.19 - - [14/Nov/2025:09:30:01 +0900] "GET /login.php?id=osaka&pass=1qaz%21QAZ HTTP/1.1" 200 403 "http://10.4.4.0/" "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0"
  \end{lstlisting}
  \end{figure}

  \subsubsection{結果}
  プログラムk061として上記のプログラムを実行した結果は以下図\ref{k061.pyの実行結果}のようになった．
  access.logの行数は78行であるため正しい結果が得られている．
  アクセス元のIPアドレスは班員の7人分あるかと思われたが，確認してみたところ班員の1人
  (38番)が逆の方のみで作業を行っていた．そのためアクセス元IPアドレス数は6人で
  間違いない．SQLインジェクションを行っていたIPアドレスも10.4.0.19, 10.4.4.0, 10.4.0.15
  以外では見つからなかった．そのため本実験課題のプログラムは正しく動いたと言える．
  実行結果が得られるまでは作成した正規表現が適しているかわからなかったが
  正しく結果が得られているためこれは今後も活用できると考えられる．

  \begin{figure}[H]
    \small
    \begin{center}
    \begin{screen}
    \begin{verbatim}
    > python k061.py access.log
    アクセス数： 78
    アクセス元のIPアドレス数： 6
    攻撃元のIPアドレス： 10.4.0.19, 10.4.4.0, 10.4.0.15
    \end{verbatim}
    \end{screen}
    \end{center} 
    \caption{k061.pyの実行結果}
    \label{k061.pyの実行結果}
  \end{figure}

  \subsection{Python,Excel間の連携}
  ここでは，Webサーバのアクセスログから「IPアドレスごとのアクセス数」を調べ，第1
  列をIPアドレス，第2列をアクセス回数とするCSVを出力し，それを元に縦軸をアクセス回
  数，横軸をIPアドレスとしたグラフを作成するプログラムについて述べる．

  \subsubsection{アイデア[5][6][7]}
  本実験課題は途中までが前課題と同じ内容である．しかし私が実験時間中にAIを用いて
  コードを出力させてみたところ，画期的な関数を発見したためこちらを活用し改めて処理を
  作り直す．用いるのはCounter関数であり，これは何が何個あるか，を数えられるものである．
  これを用いることでリスト内の重複数を数えながらIPアドレスとその回数のリストでデータを
  格納しておける．さらに.most\_common()を用いることで値（今回の場合回数）が多い
  順に並べ替えることができる．これを用いてIPアドレスとその登場回数を効率的に
  調べ活用する．Excel(csv)についての指導書に指定されている通りopenpyxlを用いる．
  Excelファイルを作るWorkbook関数や初期シートを指定できるwb.activeコマンドなどを用い
  Excelにデータを入力していく．
  最後にopenpyxlに含まれるBarChart関数で棒グラフを作成し操作する．
  Referenceコマンドで使用するデータや横軸の単位に使う値の範囲指定が行える．
  add\_dataでデータの追加，set\_categoriesで軸の単位追加，add\_chartコマンドで
  場所を決めグラフを表示することなどができる．これらを駆使しプログラムを作成する．

  \subsubsection{プログラム}
  アイデアに基づき作成したプログラムを以下に示す．授業中にAIに作成させたコードを
  そのまま使ってもよかったが，あまりに冗長（驚異の75行）だったため自分で作り直すことにした．

  \begin{figure}[H]
  \begin{lstlisting}[title={Python,Excel間の連携プログラム}]
  import sys, re, openpyxl
  from collections import Counter
  from openpyxl.chart import BarChart, Reference

  log_file, out_xlsx = sys.argv[1], sys.argv[2]
  ip_regex = re.compile(r'^(\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})')

  # 1. IP抽出と集計（Counterで一撃）
  with open(log_file, 'r', encoding='utf-8') as f:
      ips = [ip_regex.match(line).group(1) for line in f if ip_regex.match(line)]
  counts = Counter(ips).most_common() # 多い順のリストが返る

  # 2. Excel書き込み
  wb = openpyxl.Workbook()
  ws = wb.active
  ws.append(["IPアドレス", "アクセス回数"])
  for row in counts:
      ws.append(row)

  # 3. グラフ作成
  chart = BarChart()
  chart.title = "IPアクセス件数"
  data = Reference(ws, min_col=2, min_row=1, max_row=len(counts)+1)
  cats = Reference(ws, min_col=1, min_row=2, max_row=len(counts)+1)
  chart.add_data(data, titles_from_data=True)
  chart.set_categories(cats)
  ws.add_chart(chart, "D2")
  \end{lstlisting}
  \end{figure}

  新しい処理ばかりであったためほとんどアイデアで触れてしまったが行ごとに説明していく．
  1～3行目は恒例のモジュールインポートである．2,3行目で少し違う書き方なのは
  必要な機能のみをfromに続くモジュールから抜き取っているためである．
  5行目は何度も行ったコマンドライン引数定義を2つ同時に行っている．この書き方も
  AIのコードから得られた知識である．
  6行目は正規表現でここは前実験課題のプログラムと全く同じである．
  9～10行目は以前に用いているwith文とreモジュールをfor文で回す処理である．これも
  前と同じ内容だがコンパクトになっている．group(1)部分も今までと同じで
  matchしているか確認する際に正規表現で定義した()があるか確認しそこでIPアドレスを
  認識する，というものである．正規表現の方の()を消しgroup(0)とすることで同じように
  動くが，文字コードによって前後の値が数値化されIPアドレスに接触するなどを危惧し
  ()でくくっている．これも前実験と同様である，11行目は新発見関数のCounterを用い，
  登場回数をipsから集計しIPアドレスと一緒にdataの集合として格納している．さらに
  .most\_common()コマンドを用いることによってソートも同時に行っている．
  14行目は前述した通りにExcelファイルを開き，15行目も前述した通りに初期位置のシート
  （セル）を指定している．16行目は指定したところに"IPアドレス"と"アクセス回数"という
  データの見出しを入力している．この入力では"アクセス回数"がセルの初期位置の1つ右の
  セルに入力され，指導書の指定通りにデータを格納する準備が整う．17,18行目はCounterで
  格納されたデータのcountsをfor文で行ごとに入力している．これで指導書の指定通りに
  データが格納されるはずである．21行目も前述した通りBarChart関数で何も参照していない
  棒グラフを出力する．22行目で棒グラフのタイトルを決定し，23,24行目も前述した通り
  Referenceを用いて参照するデータと横軸に使う値の参照範囲を決定している，
  ここでmin\_row（行）の最初に参照する値の場所が違うのは，数値データの1段目は
  タイトルとして扱われるという仕様だからである．そのため数値データであるアクセス回数
  （登場回数）は1行先からデータを選択するのである．
  25,26行目は指定した範囲のデータと軸に使用する値をグラフに入力している．
  27行目で仕様が完全になった棒グラフをD2に配置して処理が終了する．

  \subsubsection{結果}
  本実験課題の結果として，出力されたip.csvのスクリーンショットを図\ref{ip.csv}に示す．

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{datas/ip.csv.png}
    \caption{ip.csv}
    \label{ip.csv}
  \end{figure}

  この結果は前課題で確認されたものと等しく，データとグラフの整合性もとれている．
  以上のことから本実験課題の題意を満たしたと言える．

  \subsection{発展課題}
  本実験課題では前課題で出力した棒グラフをmatplotlibを用いて出力する．

  \subsubsection{アイデア}
  アイデア自体は前の実験とおおよそ変わらない．matplotlibを用いてグラフを
  出力するところのみが前課題と違うが，正直なところリストとして用いていた値を
  別々にして直でグラフを出す，というところくらいしか違いがない．
  後はほとんど同じようなコードを参考資料を見ながら書いていく．

  \subsubsection{プログラム}
  以下にアイデアに即したプログラムを示す．

  \begin{figure}[H]
  \begin{lstlisting}[title={matplotを用い棒グラフを出力するプログラム}]
    import sys, re, matplotlib.pyplot as plt
    from collections import Counter

    ip_regex = re.compile(r'^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})')
    ips = []

    with open(sys.argv[1], 'r', encoding='utf-8') as f:
        for line in f:
            match = ip_regex.match(line)
            if match:
                ips.append(match.group(1))

    # 集計
    counts = Counter(ips).most_common()
    labels, values = zip(*counts)

    # グラフ作成
    plt.bar(labels, values)
    plt.xticks(rotation=45) 
    plt.tight_layout()
    plt.show()
  \end{lstlisting}
  \end{figure}

  14行目までは前課題と被るため説明は割愛する．
  15行目はCounterでまとめたcountsをIPアドレスだけの塊と回数だけの塊に分けている．
  これは前述した通りmatpotlibにそのまま値として参照させるためである．
  18行目は棒グラフを描画している．引数は順に横軸のデータ，縦軸のデータとなっている．
  19行目は横軸の見出しであるIPアドレスの文字を45度回転させている．そのままだと
  文字同士がかぶって大変なことになる（なった）ためである．
  20行目はグラフのタイトルやラベルがウィンドウ外にはみ出さないようにしている．
  21行目でグラフを1つのウィンドウとして出力する．

  \subsubsection{結果}
  プログラムを実行し出力されたウィンドウを図\ref{matplotlib}に示す．

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.99\textwidth]{datas/matplotlib.png}
    \caption{matplotlibで出力した棒グラフ}
    \label{matplotlib}
  \end{figure}

  図\ref{matplotlib}のグラフと図\ref{ip.csv}のグラフの値が等しいため
  プログラムは正しく動作し課題の題意を満たせたと言える．

  \newpage
  \begin{huge}
    参考文献\\\\
  \end{huge}
  % \noindent[]ページ名，\url{}，2026年01/11参照．\\
  \noindent[1]Pythonでうるう年を判定・カウント・列挙，\url{https://note.nkmk.me/python-calendar-leap-year/}，2026年01/11参照．\\
  \noindent[2]Python, set型で集合演算（和集合、積集合や部分集合の判定など），\url{https://note.nkmk.me/python-set/}，2026年01/11参照．\\
  \noindent[3]【Python】正規表現を扱うre モジュール とは？主要メソッドや活用シーンをわかりやすく解説！，\url{https://pythonaiclarifydoubts.com/python-import-re/}，2026年01/11参照．\\
  \noindent[4]re --- 正規表現操作，\url{https://docs.python.org/ja/3/library/re.html}，2026年01/11参照．\\
  \noindent[5]PythonのCounterでリストの各要素の出現個数をカウント，\url{https://note.nkmk.me/python-collections-counter/}，2026年01/11参照．\\
  \noindent[6]PythonでExcel操作を自動化しよう！openpyxl \& pandas (入門編)，\url{https://qiita.com/Yamashita_Sosuke/items/1e4d8a68d4058d1585a8}，2026年01/11参照．\\
  \noindent[7]PythonとopenpyxlでExcel作業を効率化！BarChart/BarChart3Dを使ったグラフ作成入門，\url{https://tech-compass.jp/python/python%e3%81%a8openpyxl%e3%81%a7excel%e4%bd%9c%e6%a5%ad%e3%82%92%e5%8a%b9%e7%8e%87%e5%8c%96%ef%bc%81barchart-barchart3d%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9f%e3%82%b0%e3%83%a9%e3%83%95%e4%bd%9c%e6%88%90/}，2026年01/11参照．\\
  \noindent[8]【Python初心者】Matplotlibの基本的な使い方まとめ，\url{https://qiita.com/gaku-devlog/items/5ccac4c2948dc17b5c4f}，2026年01/11参照．\\

  \newpage
  \begin{huge}
    感想\\\\
  \end{huge}
  Pythonはインデントによる強制的な可読性の向上と記述スタイルの統一感により，他者の
  コードを解読する際のストレスが少ないと感じた．豊富なモジュール群によって最小限の
  記述で実装できる点は，開発効率の面で非常に強力である．特に，実行結果を即座に確認
  できるインタプリタとしての特性はデータの整理やスクレイピングといった日常的な問題
  にも適しており，将来的にデータ分析や機械学習を扱う際にも，その優位性は極めて高いと考えた．
\end{document}
